"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[6166],{3905:function(e,t,i){i.r(t),i.d(t,{MDXContext:function(){return c},MDXProvider:function(){return m},mdx:function(){return f},useMDXComponents:function(){return d},withMDXComponents:function(){return u}});var n=i(67294);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(){return r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n])}return e},r.apply(this,arguments)}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function l(e,t){if(null==e)return{};var i,n,o=function(e,t){if(null==e)return{};var i,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||(o[i]=e[i]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var c=n.createContext({}),u=function(e){return function(t){var i=d(t.components);return n.createElement(e,r({},t,{components:i}))}},d=function(e){var t=n.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},m=function(e){var t=d(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var i=e.components,o=e.mdxType,r=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(i),m=o,h=u["".concat(a,".").concat(m)]||u[m]||p[m]||r;return i?n.createElement(h,s(s({ref:t},c),{},{components:i})):n.createElement(h,s({ref:t},c))}));function f(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=i.length,a=new Array(r);a[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<r;c++)a[c]=i[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,i)}h.displayName="MDXCreateElement"},1137:function(e,t,i){i.r(t),i.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var n=i(83117),o=i(80102),r=(i(67294),i(3905)),a=["components"],s={id:"eviction_policy",title:"Eviction policy"},l=void 0,c={unversionedId:"Cache_Library_User_Guides/eviction_policy",id:"Cache_Library_User_Guides/eviction_policy",title:"Eviction policy",description:"Cachelib offers different eviction policies, suitable for different use cases. To select a specific eviction policy, choose the appropriate allocator type.",source:"@site/docs/Cache_Library_User_Guides/eviction_policy.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/eviction_policy",permalink:"/docs/Cache_Library_User_Guides/eviction_policy",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/eviction_policy.md",tags:[],version:"current",frontMatter:{id:"eviction_policy",title:"Eviction policy"},sidebar:"userguideSidebar",previous:{title:"Item and Handle",permalink:"/docs/Cache_Library_User_Guides/Item_and_Handle"},next:{title:"Partition cache into pools",permalink:"/docs/Cache_Library_User_Guides/Partition_cache_into_pools"}},u={},d=[{value:"LRU",id:"lru",level:2},{value:"Configuration",id:"configuration",level:3},{value:"LRU 2Q",id:"lru-2q",level:2},{value:"Configuration",id:"configuration-1",level:3},{value:"TinyLFU",id:"tinylfu",level:2}],m={toc:d};function p(e){var t=e.components,s=(0,o.Z)(e,a);return(0,r.mdx)("wrapper",(0,n.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,r.mdx)("p",null,"Cachelib offers different eviction policies, suitable for different use cases. To select a specific eviction policy, choose the appropriate allocator type."),(0,r.mdx)("h2",{id:"lru"},"LRU"),(0,r.mdx)("p",null,"This is the classic least recently used (LRU) eviction policy with a couple optional modifications. We assume the reader is familiar with the classic LRU. Before we start, let's get familiar a few concepts. ",(0,r.mdx)("strong",{parentName:"p"},"Tail age")," is the time the item in the LRU tail spent in the cache. If ",(0,r.mdx)("inlineCode",{parentName:"p"},"Tins(tail)")," is the time when an item was inserted into the cache, ",(0,r.mdx)("inlineCode",{parentName:"p"},"tail_age = now() - Tins(tail)"),". ",(0,r.mdx)("strong",{parentName:"p"},"Insertion point")," (IP) is a position in LRU where a new item is inserted. Classic LRU IP is the head of the list. Moving an item from its current position in LRU to the head is called ",(0,r.mdx)("strong",{parentName:"p"},"promotion"),". Now let's look at the following picture:"),(0,r.mdx)("p",null,(0,r.mdx)("img",{src:i(12788).Z,width:"922",height:"223"})),(0,r.mdx)("p",null,"The first modification cachelib made is custom IP, which is not at the head of the list. New items will be inserted at the position ",(0,r.mdx)("inlineCode",{parentName:"p"},"ipos(p) = size(LRU) * p")," from the tail, where ",(0,r.mdx)("inlineCode",{parentName:"p"},"p \u2208 [0,1]")," is a ratio parameter. For example, suppose the regular LRU tail age be 600s, but you want to cache only items that were accessed during the 200s after insertion. Inserting new items at position ",(0,r.mdx)("inlineCode",{parentName:"p"},"ipos(1/3)")," from the tail may help you to achieve this. Note that custom IP affects only items that're inserted into the cache the first time; it doesn't affect items that on access are moved to the head of the list."),(0,r.mdx)("p",null,"The second modification is promotion delay. Normally every access item is moved to the LRU head. In fact, you need to be precise about promotions from the tail of LRU and don't bother promoting items close to the head. Before promotion, we check the time since the last promotion and promote only if it is longer than the delay parameter ",(0,r.mdx)("inlineCode",{parentName:"p"},"T"),". This is performance optimization. In the setup of the last example, you may want to promote only items with tail age of 300s, roughly when they get to the bottom half of the LRU."),(0,r.mdx)("h3",{id:"configuration"},"Configuration"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"lruRefreshTime"),"\nHow often does cachelib refresh a previously accessed item. By default this is 60 seconds.")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"updateOnWrite"),"/",(0,r.mdx)("inlineCode",{parentName:"p"},"updateOnRead"),"\nSpecifies if a LRU promotion happens on read or write or both. As a rule of thumb, for most services that care primarily about read performance, turn on ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateOnRead"),". However, if your service cares a lot about retention time of items that are recently written, then turn on ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateOnWrite")," as well. By default, ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateOnRead = true")," and ",(0,r.mdx)("inlineCode",{parentName:"p"},"updateOnWrite = false"),".")),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("p",{parentName:"li"},(0,r.mdx)("inlineCode",{parentName:"p"},"ipSpec"),"\nThis essentially turns the LRU into a two-segmented LRU. Setting this to ",(0,r.mdx)("inlineCode",{parentName:"p"},"1")," means every new insertion will be inserted 1/2 from the end of the LRU, ",(0,r.mdx)("inlineCode",{parentName:"p"},"2")," means 1/4 from the end of the LRU, and so on."))),(0,r.mdx)("h2",{id:"lru-2q"},"LRU 2Q"),(0,r.mdx)("p",null,"LRU 2Q deals with bursty accesses. The term ",(0,r.mdx)("em",{parentName:"p"},"LRU 2Q")," is a little misleading. It actually uses 3 LRUs (which are called queue here): hot, warm, and cold. Let us explain how items move between them. Look at the following picture, where the gray arrows indicate promotions:"),(0,r.mdx)("p",null,(0,r.mdx)("img",{src:i(89940).Z,width:"382",height:"552"})),(0,r.mdx)("p",null,"Initially, items are inserted into the hot queue. Items in the hot queue are promoted to the head of hot queue (internal promotion). Items evicted from the hot queue goes to the cold queue. If an item in the cold queue is accessed, it gets promoted to the ",(0,r.mdx)("strong",{parentName:"p"},"warm")," queue (cross-queue promotion). An item evicted from the cold queue gets evicted from cache. Similarly to the hot queue, an item in the warm queue s promoted internally and evicted to the cold queue."),(0,r.mdx)("p",null,"The warm queue and the cold queue are effectively an LRU with custom IP (see above) - they're the head of cold queue."),(0,r.mdx)("p",null,"Hot items evicted to the cold queue have quite limited time to get a hit and move to the warm queue. This captures items that are aggressively accessed and then are no longer used."),(0,r.mdx)("p",null,"Usually, the warm queue is about 60%, the cold queue 30%, and the hot queue 10%."),(0,r.mdx)("h3",{id:"configuration-1"},"Configuration"),(0,r.mdx)("ul",null,(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"lruRefreshTime"),"\nSame as above for memory management LRU (MMLru)."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"updateOnWrite"),"/",(0,r.mdx)("inlineCode",{parentName:"li"},"updateOnRead"),"\nSame as above for MMLru."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"hotSizePercent"),"\nThis specifies the ratio of items that will be inserted into the hot queue. Items that are never accessed in the hot queue will be moved to the cold queue, which will be evicted faster. Items that have been accessed while in the hot queue will be moved to the head of the hot queue so they will live in the hot queue for longer."),(0,r.mdx)("li",{parentName:"ul"},(0,r.mdx)("inlineCode",{parentName:"li"},"coldSizePercent"),"\nItems that are accessed in the cold queue will be moved to the warm queue. Increasing this ratio can give the items accessed on a longer, but regular period a higher chance to stay in the cache.")),(0,r.mdx)("h2",{id:"tinylfu"},"TinyLFU"),(0,r.mdx)("p",null,"TinyLFU consists of two parts: frequency estimator (FE) and LRU. FE is an approximate data structure that computes an item's access frequency (Count-Min Sketch used) before inserting it to LRU. Only items that pass frequency threshold get accepted to LRU and evicted otherwise."))}p.isMDXComponent=!0},89940:function(e,t,i){t.Z=i.p+"assets/images/cachelib_2Q-14acaae058c03bdf08425a94a534845b.png"},12788:function(e,t,i){t.Z=i.p+"assets/images/cachelib_LRU-4ded88fcaa39ccd440f4e069923501d2.png"}}]);