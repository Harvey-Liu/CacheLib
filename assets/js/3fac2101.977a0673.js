"use strict";(self.webpackChunkcachelib=self.webpackChunkcachelib||[]).push([[2344],{3905:function(e,n,t){t.r(n),t.d(n,{MDXContext:function(){return s},MDXProvider:function(){return u},mdx:function(){return f},useMDXComponents:function(){return p},withMDXComponents:function(){return d}});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(){return i=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e},i.apply(this,arguments)}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),d=function(e){return function(n){var t=p(n.components);return o.createElement(e,i({},n,{components:t}))}},p=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},u=function(e){var n=p(e.components);return o.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(t),u=a,h=d["".concat(r,".").concat(u)]||d[u]||m[u]||i;return t?o.createElement(h,c(c({ref:n},s),{},{components:t})):o.createElement(h,c({ref:n},s))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=h;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,r[1]=c;for(var s=2;s<i;s++)r[s]=t[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},7344:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return p}});var o=t(83117),a=t(80102),i=(t(67294),t(3905)),r=["components"],c={id:"Tuning_DRAM_cache_efficiency",title:"Tuning DRAM cache efficiency"},l=void 0,s={unversionedId:"Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency",id:"Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency",title:"Tuning DRAM cache efficiency",description:"Reduce fragmentation",source:"@site/docs/Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency.md",sourceDirName:"Cache_Library_User_Guides",slug:"/Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency",permalink:"/docs/Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency",draft:!1,editUrl:"https://github.com/facebook/CacheLib/edit/main/website/docs/Cache_Library_User_Guides/Tuning_DRAM_cache_efficiency.md",tags:[],version:"current",frontMatter:{id:"Tuning_DRAM_cache_efficiency",title:"Tuning DRAM cache efficiency"},sidebar:"userguideSidebar",previous:{title:"FDP enabled cache",permalink:"/docs/Cache_Library_User_Guides/FDP_enabled_Cache"},next:{title:"CacheLib configs",permalink:"/docs/Cache_Library_User_Guides/CacheLib_configs"}},d={},p=[{value:"Reduce fragmentation",id:"reduce-fragmentation",level:2},{value:"Configure TTL reaper",id:"configure-ttl-reaper",level:2},{value:"Enable pool rebalancing",id:"enable-pool-rebalancing",level:2},{value:"Avoid copying from cache",id:"avoid-copying-from-cache",level:2},{value:"Tune eviction policy",id:"tune-eviction-policy",level:2},{value:"Reduce lock contention",id:"reduce-lock-contention",level:2}],u={toc:p};function m(e){var n=e.components,t=(0,a.Z)(e,r);return(0,i.mdx)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.mdx)("h2",{id:"reduce-fragmentation"},"Reduce fragmentation"),(0,i.mdx)("p",null,"When you use cachelib to allocate memory from cache, you get a piece of memory rounded up to the closest allocation size in the cache. This can lead to wastage of memory (e.g., if you allocate 60 bytes, you get  memory from the 80-byte allocation class; 20 bytes is wasted). Typically, once this grows beyond 5%, there is an opportunity to reduce the fragmentation and increase the usable cache size by tuning the internal allocation sizes."),(0,i.mdx)("p",null,"To estimate the current fragmentation size, use CacheStat::fragmentationSize to get the current fragmentation bytes and see if the overall volume is more than 5% of your cache size. You can find out the fragmentation per pool by calling PoolStats::totalFragmentation()."),(0,i.mdx)("p",null,(0,i.mdx)("em",{parentName:"p"},"Note that changing allocation sizes would need the cache to be dropped if you have cache persistence enabled.")),(0,i.mdx)("h2",{id:"configure-ttl-reaper"},"Configure TTL reaper"),(0,i.mdx)("p",null,"If you have enabled TTL for your objects, reaping them as soon as they expire would free up the space for other objects that can benefit from more cache space. If you don\u2019t pass a TTL to ",(0,i.mdx)("inlineCode",{parentName:"p"},"allocate()")," and you don\u2019t think you have a notion of TTL, you can ignore this."),(0,i.mdx)("p",null,(0,i.mdx)("strong",{parentName:"p"},"Remediation"),": Please follow the instructions on ",(0,i.mdx)("a",{parentName:"p",href:"ttl_reaper/"},"time to live on item")," to turn on the reaper. If you have a reaper already and don\u2019t have the ",(0,i.mdx)("inlineCode",{parentName:"p"},"slabWalk")," mode enabled, enabling it would speed up the reaping of the expired items."),(0,i.mdx)("h2",{id:"enable-pool-rebalancing"},"Enable pool rebalancing"),(0,i.mdx)("p",null,"If your objects are of different sizes, their relative memory footprint in the cache might be suboptimal. For example, you might have too many of the large objects hogging space or certain sized objects getting evicted faster than the other. These can lead to suboptimal hit ratios. Turning on pool rebalancing can help in this."),(0,i.mdx)("p",null,"There isn\u2019t an easy way to tell if this is causing regressions; the easiest way is to experiment on a small test environment with a few ",(0,i.mdx)("a",{parentName:"p",href:"pool_rebalance_strategy/#picking-a-strategy"},"options")," offered by cachelib. Tuning this often results in improvements to hit ratio."),(0,i.mdx)("h2",{id:"avoid-copying-from-cache"},"Avoid copying from cache"),(0,i.mdx)("p",null,"If your mode of operation to access the cache is to copy from cache to deserialize or send out of the network, you can usually avoid the copy by passing the ",(0,i.mdx)("inlineCode",{parentName:"p"},"ItemHandle")," to the appropriate places. For example, if you read from the cache and copy into Thrift reply, you can avoid the copy by converting the ",(0,i.mdx)("inlineCode",{parentName:"p"},"ItemHandle")," into an ",(0,i.mdx)("inlineCode",{parentName:"p"},"IOBuf"),". Similarly, if you copy to deserialize, you can avoid this by deserializing out of the ",(0,i.mdx)("inlineCode",{parentName:"p"},"IOBuf")," from ",(0,i.mdx)("inlineCode",{parentName:"p"},"ItemHandle"),"."),(0,i.mdx)("p",null,"To estimate if this is an issue, collect a cpu profile to see if you spend more than a few % cycles on memcpy variants. If you do, follow some of the examples in ",(0,i.mdx)("inlineCode",{parentName:"p"},"convertToIoBuf")," to try to accomplish similar things."),(0,i.mdx)("h2",{id:"tune-eviction-policy"},"Tune eviction policy"),(0,i.mdx)("p",null,"Both ",(0,i.mdx)("inlineCode",{parentName:"p"},"LruAllocator")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"Lru2QAllocator")," provide knobs to tune them that are mostly turned off. Trying these out could improve hit ratio. For example, if you are using LRU, trying to turn on mid-point insertion could help get objects that are accessed just once out of the cache faster. Similarly, trying the 2Q allocator captures more access patterns that LRU doesn\u2019t (e.g., 2Q can effectively evict items that have spiky accesses after the spike had ceased)."),(0,i.mdx)("p",null,"For more details on the available knobs, see ",(0,i.mdx)("a",{parentName:"p",href:"eviction_policy/"},"eviction policy"),"."),(0,i.mdx)("h2",{id:"reduce-lock-contention"},"Reduce lock contention"),(0,i.mdx)("p",null,"Cachelib has locks at several granularity to protect the internal data structures. If there is a contention, there are few options to reduce the contention depending on the type."),(0,i.mdx)("p",null,"To estimate, collect a strobelight profile. If the strobelight profile indicates double-digit percentage CPU spent across ",(0,i.mdx)("inlineCode",{parentName:"p"},"allocate()"),", ",(0,i.mdx)("inlineCode",{parentName:"p"},"insertOrReplace()")," and ",(0,i.mdx)("inlineCode",{parentName:"p"},"find()"),", there is potential to optimize this further."),(0,i.mdx)("ul",null,(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Contention in ",(0,i.mdx)("inlineCode",{parentName:"p"},"find()"),"\nIf you see contention in ",(0,i.mdx)("inlineCode",{parentName:"p"},"find()")," resulting in ",(0,i.mdx)("inlineCode",{parentName:"p"},"SharedMutex")," showing up beneath it, this could be due to hashtable being sized too small. Check the number of items in your cache and also the hashpower for the hashtable. In general, we want the hashtable to have a load factor around 0.5 (e.g. 150M items needs a hashpower of 2^28 (256M slots)).")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Contention in ",(0,i.mdx)("inlineCode",{parentName:"p"},"insertOrReplace"),"\nIf you see contention in ",(0,i.mdx)("inlineCode",{parentName:"p"},"insertOrReplace")," resulting in ",(0,i.mdx)("inlineCode",{parentName:"p"},"SharedMutex")," showing up beneath it, usually this is a result of misconfigured Hashtable. This can be tuned by adjusting the ",(0,i.mdx)("a",{parentName:"p",href:"Configure_HashTable/#lockspower"},"lockPower"),".")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Contention in ",(0,i.mdx)("inlineCode",{parentName:"p"},"addChainedItem")," (or related functions)\nSimilar to above, we have a separate hash table to keep track of chained items. If you see contention here, adjust lockPower the same way as above.")),(0,i.mdx)("li",{parentName:"ul"},(0,i.mdx)("p",{parentName:"li"},"Contention in LRU\nIf you notice contention under MMLru or MM2Q, it indicates you have quite a lot of activity (400k/sec+) concentrated around objects of a particular size. To remediate this, we have a few options. If the number of ",(0,i.mdx)("inlineCode",{parentName:"p"},"allocate()")," calls per alloc size is too high, sharding the ",(0,i.mdx)("inlineCode",{parentName:"p"},"allocate()")," calls by creating additional pools would help (e.g. create 8 pools and use ",(0,i.mdx)("inlineCode",{parentName:"p"},"poolId = hash(key) % 8")," when calling into allocate()) If the contention is coming from ",(0,i.mdx)("inlineCode",{parentName:"p"},"find()"),", adjusting the ",(0,i.mdx)("inlineCode",{parentName:"p"},"lruRefreshThreshold")," or turning on ",(0,i.mdx)("inlineCode",{parentName:"p"},"dynamicLruRefreshThreshold")," could help as documented in ",(0,i.mdx)("a",{parentName:"p",href:"eviction_policy/"},"eviction policy"),"."))))}m.isMDXComponent=!0}}]);